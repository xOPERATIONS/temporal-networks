var searchIndex={};
searchIndex["temporal_networks"] = {"doc":"Temporal Networks Temporal Networks for fast and flexible…","i":[[5,"install","temporal_networks","Recommended to run once when this package imported in JS…",null,[[],[["result",["jsvalue"]],["jsvalue"]]]],[5,"__wasm_bindgen_generated_install","","Recommended to run once when this package imported in JS…",null,[[]]],[0,"algorithms","","",null,null],[5,"floyd_warshall","temporal_networks::algorithms","Similar to Python's networkx Floyd Warshall…",null,[[["digraphmap"]],[["btreemap",["f64"]],["string"],["result",["btreemap","string"]]]]],[0,"interval","temporal_networks","",null,null],[3,"Interval","temporal_networks::interval","An interval represents a context-agnostic inclusive…",null,null],[12,"0","","",0,null],[12,"1","","",0,null],[11,"new","","Create a new Interval",0,[[["f64"]],["interval"]]],[11,"from_vec","","Get an interval from a vector",0,[[["vec",["f64"]],["f64"]],["interval"]]],[11,"to_json","","Convert the interval to JSON `[lower, upper]`",0,[[["self"]],["jsvalue"]]],[11,"lower","","The lower bound of the range",0,[[["self"]],["f64"]]],[11,"upper","","The upper bound of the range",0,[[["self"]],["f64"]]],[11,"contains","","Whether or not a point in time falls within a range",0,[[["f64"],["self"]],["bool"]]],[11,"is_valid","","A check that ensures the lower bound is less than the…",0,[[["self"]],["bool"]]],[0,"plan","temporal_networks","Plan Defines an API designed to be exported to WASM that…",null,null],[3,"Step","temporal_networks::plan","A Step represents a logical action that occurs over a…",null,null],[12,"0","","",1,null],[12,"1","","",1,null],[3,"Plan","","A `Plan` orchestrates events and the timing constraints…",null,null],[11,"name","","Represents the unique identifier of the step",1,[[["self"]],["string"]]],[11,"start","","Represents the start of the step",1,[[["self"]],["i32"]]],[11,"end","","Represents the end of the step",1,[[["self"]],["i32"]]],[11,"new","","",2,[[],["plan"]]],[11,"root","","Get the first event in the plan. Found implicitly based on…",2,[[["self"]],[["option",["i32"]],["i32"]]]],[11,"create_event","","Low-level API for creating nodes in the graph. Advanced…",2,[[["self"],["string"]],["i32"]]],[11,"add_step","","Create a new step and add it to this plan. The identifier…",2,[[["string"],["option",["vec"]],["self"],["vec",["f64"]]],["step"]]],[11,"get_duration","","Get the controllable duration of a step",2,[[["self"],["step"]],["interval"]]],[11,"compile","","Compile the plan into a dispatchable form. A dispatchable…",2,[[["self"]],[["result",["jsvalue"]],["jsvalue"]]]],[11,"complete_step","","",2,[[]]],[11,"interval","","Get the interval between two events",2,[[["self"],["i32"]],[["result",["interval","jsvalue"]],["jsvalue"],["interval"]]]],[11,"event_distance","","Low-level API to get the directional distance between two…",2,[[["self"],["i32"]],[["jsvalue"],["result",["jsvalue","jsvalue"]]]]],[11,"update_duration","","",2,[[]]],[11,"add_constraint","","Add a constraint between the start or end of two events.…",2,[[["option",["vec"]],["i32"],["self"],["vec",["f64"]]],[["result",["jsvalue"]],["jsvalue"]]]],[11,"remove_constrainst","","",2,[[]]],[11,"remove_constrainsts","","",2,[[]]],[11,"from","temporal_networks::interval","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"return_abi","","",0,[[]]],[11,"from","temporal_networks::plan","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"return_abi","","",1,[[]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"return_abi","","",2,[[]]],[11,"clone","temporal_networks::interval","",0,[[["self"]],["interval"]]],[11,"clone","temporal_networks::plan","",1,[[["self"]],["step"]]],[11,"default","temporal_networks::interval","",0,[[],["interval"]]],[11,"default","temporal_networks::plan","",1,[[],["step"]]],[11,"default","","",2,[[],["plan"]]],[11,"eq","temporal_networks::interval","",0,[[["interval"],["self"]],["bool"]]],[11,"ne","","",0,[[["interval"],["self"]],["bool"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","temporal_networks::plan","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","temporal_networks::interval","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","temporal_networks::plan","",1,[[["formatter"],["self"]],["result"]]],[11,"sub","temporal_networks::interval","",0,[[["interval"]],["interval"]]],[11,"add","","create a new interval from the addition of two other…",0,[[["interval"]],["interval"]]],[11,"neg","","",0,[[],["interval"]]],[11,"add_assign","","",0,[[["self"],["interval"]]]],[11,"sub_assign","","",0,[[["self"],["interval"]]]],[11,"bitand","","",0,[[["interval"]],["interval"]]],[11,"bitand_assign","","",0,[[["self"],["interval"]]]],[11,"ref_from_abi","","",0,[[]]],[11,"ref_from_abi","temporal_networks::plan","",1,[[]]],[11,"ref_from_abi","","",2,[[]]],[11,"from_abi","temporal_networks::interval","",0,[[["u32"]],["self"]]],[11,"from_abi","temporal_networks::plan","",1,[[["u32"]],["self"]]],[11,"from_abi","","",2,[[["u32"]],["self"]]],[11,"into_abi","temporal_networks::interval","",0,[[],["u32"]]],[11,"into_abi","temporal_networks::plan","",1,[[],["u32"]]],[11,"into_abi","","",2,[[],["u32"]]],[11,"describe","temporal_networks::interval","",0,[[]]],[11,"describe","temporal_networks::plan","",1,[[]]],[11,"describe","","",2,[[]]],[11,"is_none","temporal_networks::interval","",0,[[],["bool"]]],[11,"is_none","temporal_networks::plan","",1,[[],["bool"]]],[11,"is_none","","",2,[[],["bool"]]],[11,"none","temporal_networks::interval","",0,[[]]],[11,"none","temporal_networks::plan","",1,[[]]],[11,"none","","",2,[[]]],[11,"ref_mut_from_abi","temporal_networks::interval","",0,[[]]],[11,"ref_mut_from_abi","temporal_networks::plan","",1,[[]]],[11,"ref_mut_from_abi","","",2,[[]]],[11,"serialize","temporal_networks::interval","",0,[[["self"],["__s"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]]],"p":[[3,"Interval"],[3,"Step"],[3,"Plan"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);